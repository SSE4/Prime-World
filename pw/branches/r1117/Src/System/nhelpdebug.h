#pragma once
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef _NSTL_HELP_DEBUG
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "nstring.h"
#include "nalgoritm.h"
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace NStr
{
	const char *StrFmt( const char *pszFormat, ... );
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace NHelpDebug
{
using namespace nstl;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const int NSTL_HELP_DEBUG_MAX_BUF_SIZE = 1024 * 8;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Возвращает строку, содержащую текстовое представление контейнера (в виде дерева)
// Например, Look( cont ), Look( GetAt( cont, 3 ) )
// Длина строка под отладчиком ограничена 256 символами, в этом случае можно использовать, 
// например, AfxTrace( Look( cont ) )
template<class T>
inline const char* Look( T &contaner )
{
	const int buf_size = NSTL_HELP_DEBUG_MAX_BUF_SIZE;
	static char buf[buf_size];

	strncpy_s( buf, LookPrivate( &contaner ).c_str(), buf_size - 1 );

	buf[buf_size - 1] = 0;
	return buf;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
inline void LookInit( T &container )
{
	if ( false ) // yes, it's true - for template instantiation only
	{
		container.size();
		container.Look();

		T::iterator iter( container.begin() );
		container.LookIter( &iter );
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
inline string LookContainer( const T *pContainer )
{
	if ( !pContainer->empty() )
	{
		string szAnswer = string( "{ " );
		for ( T::const_iterator it = pContainer->begin(); it != pContainer->end(); ++it )
			szAnswer += LookPrivate( &(*it) ) + ", ";

		szAnswer[szAnswer.size() - 2] = ' ';
		szAnswer[szAnswer.size() - 1] = '}';

		return szAnswer;
	}
	else
		return "{}";
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline string LookPrivate( ... )
{
	return "unknown";
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline string LookPrivate( const string *psz )
{
	return *psz;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline string LookPrivate( const int *pn )
{
	return NI_STRFMT( "%d", *pn );
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline string LookPrivate( const float *pf )
{
	return NI_STRFMT( "%d", *pf );
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
inline string LookPrivate( const vector<T> *pContainer )
{
	return LookContainer( pContainer );
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
inline string LookPrivate( const list<T> *pContainer )
{
	return LookContainer( pContainer );
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, class F>
inline string LookPrivate( const hash_set<T, F> *pSet )
{
	if ( !pSet->empty() )
	{
		string szAnswer = string( "{ " );
		for ( hash_set<T, F>::const_iterator it = pSet->begin(); it != pSet->end(); ++it )
		{
			string szElement = LookPrivate( &(*it) );
			const int nIndex = szElement.rfind( ',' );

			szAnswer += szElement.substr( 0, nIndex - 1 ) + ", ";
		}

		szAnswer[szAnswer.size() - 2] = ' ';
		szAnswer[szAnswer.size() - 1] = '}';

		return szAnswer;
	}
	else
		return "{}";
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class K, class T, class F>
inline string LookPrivate( const hash_map<K, T, F> *pContainer )
{
	return LookContainer( pContainer );
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class K, class T>
inline string LookPrivate( const pair<K, T> *el )
{
	return "{ " + LookPrivate( &el->first ) + ", " + LookPrivate( &el->second ) + " }";
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif //_NSTL_HELP_DEBUG
